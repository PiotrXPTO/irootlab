%>@brief Log generated by an @ref as_fsel class
classdef log_as_fsel < irlog
    properties        
        %> =[]. Indexes of selected features.
        v = [];
        %> Grades
        grades;
        %> x-values to which @ref grades are the y-values
        fea_x;
        %> (Cell of strings) Feature names. Same number of elements as fea_x
        fea_names;
        %> x-axis label
        xname = '';
        %> Unit of x-axis
        xunit;
        %> y-axis label (e.g., "classification rate", "-log_{10}(p-value)")
        yname;
        %> Unit of y-axis (unit of the values inside grades, e.g., "%")
        yunit;
    end;
    
    methods    
        function o = log_as_fsel()
            o.classtitle = 'Feature Selection';
            o.moreactions = [o.moreactions, {'extract_fsel'}];
            o.flag_ui = 0;
        end;

        %> @return an @ref fsel block with the selection in @ref fsel::v
        function blk = extract_fsel(o)
            blk = fsel();
            blk = blk.copy_axes_from(o);
            blk.v = o.v;
            blk.grades = o.grades;
        end;
    end;
    
    
    %----------ALL THIS DRAWING STUFF!
    methods
        function o = draw(o, data_hint, flag_mark)
            if ~exist('data_hint', 'var')
                data_hint = [];
            end;
            
            if ~exist('flag_mark', 'var')
                flag_mark = 0;
            end;
            
            o.draw_grades(data_hint, 0);
            if flag_mark
                o.draw_markers();
            end;
            
            o.draw_finish();
        end;
        
        %> Gray columns for the features that were NOT selected
        function draw_hachures(o, x, ymax)
            if length(x) > 1
                idxs = 1:length(o.grades);
                idxs(o.v) = []; % I made the algorithm below in a complement fashion, then realized the mistake
                
                ni = length(idxs);
                
                for i = 1:ni+1
                    if i > ni && ni > 0 || (i > 1 && idxs(i)-idxs(i-1) > 1)
                        
                        if idxs(i1) == 1 % if feature is first one, picks distance between x-points from right
                            len = x(idxs(i1)+1)-x(idxs(i1));
                        else
                            len = x(idxs(i1))-x(idxs(i1)-1);
                        end;
                        x1 = x(idxs(i1))-len/4;
                        
                        i2 = i-1;
                        if idxs(i2) == length(x) % similar thing
                            len = x(idxs(i2))-x(idxs(i2)-1);
                        else
                            len = x(idxs(i2)+1)-x(idxs(i2));
                        end;
                        x2 = x(idxs(i2))+len/4;
                        

                        if x2 < x1 % case when the x-axis is reversed
                            temp = x2;
                            x2 = x1;
                            x1 = temp;
                        end;
                        wid = x2-x1;
                        if wid < 0 % case when the x-axis is reversed
                            wid = -wid;
                        end;
                        draw_hachure([x1, 0, wid, ymax]);
                        hold on;
                        i1 = i;
                    elseif i == 1
                        i1 = i;
                    end;
                end;
            end;
        end;


        function o = draw_grades(o, data_hint, flag_histogram)
            if any(o.grades ~= 0)
                if ~isempty(data_hint)
                    xhint = data_hint.fea_x;
                    yhint = mean(data_hint.X);
                else
                    xhint = [];
                    yhint = [];
                end;

                draw_loadings(o.fea_x, o.grades, xhint, yhint, [], 0, [], 0, 0, 0, flag_histogram);
            end;
        end;
        
        function o = draw_markers(o)
            if all(o.grades == 0)
                plot(o.fea_x([1, end]), [0, 0], 'LineWidth', scaled(3), 'Color', [0, 0, 0]);
                hold on;
                draw_peaks(o.fea_x, o.grades, o.v, 0, find_color(1), 'p', scaled(20));
            else
                draw_peaks(o.fea_x, o.grades, o.v, 0);
            end;
        end;

        %> Takes care of axes, Frank, box
        function o = draw_finish(o)
            g = o.grades;
            g(g == Inf) = [];
            ymin = 0;
            ymax = max(g)*1.05;
            if ymax == 0
                ymax = 1;
                ymin = -1;
                ylabel('');
                set(gca, 'ytick', []);
            else
                format_yaxis(o);
            end;
            set(gca, 'ylim', [ymin, ymax]);
            format_frank();
            format_xaxis(o);
            
            make_box();
        end;
    end;
end
