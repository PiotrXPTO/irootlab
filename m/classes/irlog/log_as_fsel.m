%>@brief Log generated by an @ref as_fsel class
classdef log_as_fsel < irlog
    properties        
        %> =[]. Indexes of selected features.
        v = [];
        %> Grades
        grades;
        %> x-values to which @ref grades are the y-values
        fea_x;
        %> x-axis label
        xname = '';
        %> Unit of x-axis
        xunit;
        %> y-axis label (e.g., "classification rate", "-log_{10}(p-value)")
        yname;
        %> Unit of y-axis (unit of the values inside grades, e.g., "%")
        yunit;
    end;
    
    methods    
        function o = log_as_fsel()
            o.classtitle = 'Feature Selection';
            o.moreactions = [o.moreactions, {'extract_fsel'}];
        end;
        
        function blk = extract_fsel(o)
            blk = fsel();
            blk.v = o.v;
            blk.fea_x = o.fea_x;
            blk.xname = o.xname;
            blk.yname = o.yname;
            blk.xunit = o.xunit;
%             blk.yunit = o.yunit;
            blk.grades = o.grades;
        end;
    end;
    
    
    %----------ALL THIS DRAWING STUFF!
    methods
        function o = draw(o, data_hint, flag_mark)
            if ~exist('data_hint', 'var')
                data_hint = [];
            end;
            
            if ~exist('flag_mark', 'var')
                flag_mark = 0;
            end;
            
            o.draw_grades(data_hint, 0);
            if flag_mark
                o.draw_markers();
            end;
            
            o.draw_finish();
        end;
        
        %> Gray columns for the features that were NOT selected
        function draw_hachures(o, x, ymax)
            if length(x) > 1
                idxs = 1:length(o.grades);
                idxs(o.v) = []; % I made the algorithm below in a complement fashion, then realized the mistake
                
                ni = length(idxs);
                
                for i = 1:ni+1
                    if i > ni && ni > 0 || (i > 1 && idxs(i)-idxs(i-1) > 1)
                        
                        if idxs(i1) == 1 % if feature is first one, picks distance between x-points from right
                            len = x(idxs(i1)+1)-x(idxs(i1));
                        else
                            len = x(idxs(i1))-x(idxs(i1)-1);
                        end;
                        x1 = x(idxs(i1))-len/4;
                        
                        i2 = i-1;
                        if idxs(i2) == length(x) % similar thing
                            len = x(idxs(i2))-x(idxs(i2)-1);
                        else
                            len = x(idxs(i2)+1)-x(idxs(i2));
                        end;
                        x2 = x(idxs(i2))+len/4;
                        

                        if x2 < x1 % case when the x-axis is reversed
                            temp = x2;
                            x2 = x1;
                            x1 = temp;
                        end;
                        wid = x2-x1;
                        if wid < 0 % case when the x-axis is reversed
                            wid = -wid;
                        end;
                        draw_hachure([x1, 0, wid, ymax]);
                        hold on;
                        i1 = i;
                    elseif i == 1
                        i1 = i;
                    end;
                end;
            end;
        end;


        function o = draw_grades(o, data_hint, flag_histogram)
            if ~isempty(data_hint)
                xhint = data_hint.fea_x;
                yhint = mean(data_hint.X);
            else
                xhint = [];
                yhint = [];
            end;
            
            draw_loadings(o.fea_x, o.grades, xhint, yhint, [], 0, [], 0, 0, 0, flag_histogram);
            format_xaxis(o);
            format_yaxis(o);
        end;
        
        function o = draw_markers(o)
            draw_peaks(o.fea_x, o.grades, o.v, 0);
        end;

        function o = draw_finish(o)
        end;
    end;
end
