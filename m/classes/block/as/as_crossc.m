%> @brief Cross-calculation Analysis Session
%>
%> Allows one to extract elements:
%> @arg The average loadings matrix
%> @arg Each individually trained block and respective output dataset
%>
%> Cross-calculation means calculating the output by means of
%> cross-validation. The idea is to generate the output in several parts,
%> where each part was generated by a block trained with a dataset where
%> that part was not included.
%>
%> This is related to the idea of Stacked Generalization [1]. See also [2]
%> for a simple comprehensive text.
%>
%> <h3>References</h3>
%> [1] Wolpert, "Stacked Generalization", 1992.
%>
%> [2] Kuncheva, "Combining Pattern Classifiers", 2004, page 109.
classdef as_crossc < as
    properties
        %> (optional) SGS, preferrably a cross-validation (@ref sgs_crossval).
        %>
        %> This property is optional. If not specified, if will default to a a Leave-One-Out Cross-validation with sgs::flag_group = 1
        sgs;
        %> Mold block
        mold;
    end;
    
    properties (SetAccess=protected)
        obsidxs;
        %> This will be set at go() time and used subsequently to reorder
        %> the classlabels of extracted dataset(s)
        classlabels;
    end;

    methods
        function o = as_crossc()
            o.classtitle = 'Cross-Calculate';
        end;
    end;
    
    
    methods(Access=protected)
        %> Populates the @ref log_crossc and @ref data_out properties
        %>
        function log = do_use(o, data)
            log = log_as_crossc();
            if isempty(o.sgs)
                irverbose('Creating default Leave-One-Out Cross-validation SGS...', 1);
                sgs = sgs_crossval(); %#ok<*PROP>
                sgs.flag_group = 1;
                sgs.flag_perclass = 0;
                sgs.randomseed = 0;
                sgs.flag_loo = 1;
                log.sgs = sgs;
            else
                log.sgs = o.sgs;
            end;
            
            log.obsidxs = log.sgs.get_obsidxs(data);
            no_reps = size(log.obsidxs, 1);

            mold_ = o.mold.boot();
            flag_linear = isa(mold_, 'fcon_linear') || isa(mold_, 'block_cascade_base') && mold_.flag_fcon_linear;

            if flag_linear
                block_ref = mold_.train(data); % Trains the mold block on the whole dataset to have its loadings as a loadings orientation reference
            end;
                
            
            ipro = progress2_open('as_crossc', [], 0, no_reps);
            for i_rep = 1:no_reps
                d_train = data.map_rows(log.obsidxs{i_rep, 1});
                d_test = data.map_rows(log.obsidxs{i_rep, 2});

                block = mold_.train(d_train);
                if flag_linear
                    if i_rep > 1
                        if any(size(block.L) ~= size(block_last.L))
                            s = ['Sorry, mate but blocks are giving different L sizes: ', mat2str([size(block.L)]), ...
                                ' xxx ', mat2str(size(block_last.L)), '. Try limiting the number of loadings to ', ...
                                min(size(block.L, 2), size(block_last.L, 2))];
                            irerror(s);
                        end;
                    end;            
                    
                    M = adjust_turn2(block, block_ref);
                    if ~isempty(M)
                        % Inserts a blok at the end
                        fcomino = fcon_linear();
                        fcomino.L = M;
                        block = make_one({block, fcomino});
                        block = block.boot();
                        block = block.train(d_train); % Trains again, who cares
                    end;

                end;

                
                if i_rep == 1
                    log.data_out = block.use(d_test);
                else
                    log.data_out(i_rep) = block.use(d_test);
                end;
                        
                log.blocks{i_rep} = block;
                
                if flag_linear
                    block_last = block;
                end;
                
                ipro = progress2_change(ipro, [], [], i_rep);
            end;
            progress2_close(ipro);
            
            log.classlabels = data.classlabels;
        end;
    end;
end
